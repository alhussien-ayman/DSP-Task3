<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mini Waveform Viewer + Playhead (Plotly)</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:20px;background:#f7f9fc;color:#111}
    .panel{max-width:900px;margin:0 auto;background:white;padding:16px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    h2{margin-top:0;font-size:18px}
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    input[type=file]{display:block}
    button{padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:#fff;cursor:pointer}
    button.primary{background:#0d6efd;color:white;border-color:#0d6efd}
    #plot{height:240px}
    .note{font-size:12px;color:#666;margin-top:8px}
  </style>
</head>
<body>
  <div class="panel">
    <h2>Mini Waveform Viewer + Playhead (Plotly)</h2>

    <div class="controls">
      <input id="fileInput" type="file" accept="audio/*" />
      <button id="playPause" class="primary" disabled>Play</button>
      <div id="timeDisplay">00:00 / 00:00</div>
    </div>

    <div id="plot"></div>

    <div class="note">
      Click or drag on the waveform to scrub. If the audio was paused before scrubbing, releasing will return the playhead to the last played position (preview behavior). If audio was playing, scrubbing will seek and continue playback.
    </div>

    <!-- hidden audio element used for playback -->
    <audio id="audio" crossorigin="anonymous" style="display:none"></audio>
  </div>

<script>
(async function(){
  const fileInput = document.getElementById('fileInput');
  const audioEl = document.getElementById('audio');
  const playPauseBtn = document.getElementById('playPause');
  const timeDisplay = document.getElementById('timeDisplay');
  const plotDiv = document.getElementById('plot');

  let audioBuffer = null;
  let duration = 0;
  let downsampled = null;
  let isPlaying = false;
  let rafId = null;

  // For scrub/preview behavior:
  let scrubbing = false;
  let wasPlayingBeforeScrub = false;
  let lastPlayedTime = 0;

  // minimal empty waveform for initial state
  Plotly.newPlot(plotDiv, [{
    x: [0,1],
    y: [0,0],
    mode: 'lines',
    line: {width:1},
    fill: 'tozeroy',
    hoverinfo: 'skip',
  }], {
    margin: {t:8, b:30, l:40, r:8},
    xaxis: {showgrid:false, zeroline:false, title:'Time (s)'},
    yaxis: {showgrid:false, zeroline:false, visible:false},
  }, {displayModeBar:false});

  // load & decode file
  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const arrayBuffer = await file.arrayBuffer();
    // decode using WebAudio
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    try {
      audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    } catch(err){
      alert('Could not decode audio: ' + err);
      return;
    }
    duration = audioBuffer.duration;
    // fill hidden audio element for playback (object URL)
    const fileUrl = URL.createObjectURL(file);
    audioEl.src = fileUrl;
    audioEl.load();

    // downsample waveform for plotting (max per bucket)
    downsampled = getDownsampledWaveform(audioBuffer, 2000); // ~2000 points
    renderWaveform(downsampled, audioBuffer.duration);

    playPauseBtn.disabled = false;
    playPauseBtn.textContent = 'Play';
    updateTimeDisplay();
  });

  // simple downsampling: take peak (abs max) in each segment
  function getDownsampledWaveform(buffer, targetPoints=2000){
    const channelData = buffer.getChannelData(0); // use first channel
    const len = channelData.length;
    const step = Math.floor(len / targetPoints) || 1;
    const out = [];
    for(let i=0;i<len;i+=step){
      let max = 0;
      for(let j=i; j < Math.min(i+step, len); j++){
        const v = Math.abs(channelData[j]);
        if(v > max) max = v;
      }
      out.push(max);
    }
    // create mirrored waveform (positive & negative) for nicer fill
    const x = out.map((_,i)=> i * (buffer.duration / out.length));
    const yTop = out;
    const yBottom = out.map(v => -v);
    const xs = [...x, ...x.slice().reverse()];
    const ys = [...yTop, ...yBottom.reverse()];
    return {x: xs, y: ys, duration: buffer.duration, compactX: x};
  }

  // render Plotly waveform
  function renderWaveform(ds, dur){
    const trace = {
      x: ds.x,
      y: ds.y,
      mode: 'lines',
      line: {width:1},
      fill: 'toself',
      hoverinfo: 'x+y',
      showlegend: false,
    };
    const layout = {
      margin: {t:8, b:30, l:40, r:8},
      xaxis: {range: [0, dur], title: 'Time (s)'},
      yaxis: {visible:false, range: [-1,1]},
      shapes: [
        // vertical playhead
        {
          type: 'line',
          x0: 0,
          x1: 0,
          y0: -1,
          y1: 1,
          line: {color: 'red', width: 1.5},
          xref: 'x',
          yref: 'y',
          name: 'playhead'
        }
      ],
    };
    Plotly.react(plotDiv, [trace], layout, {displayModeBar:false});
  }

  // update playhead shape position (x)
  async function setPlayhead(time){
    if(!duration) return;
    // clamp
    const t = Math.max(0, Math.min(duration, time));
    await Plotly.relayout(plotDiv, {
      'shapes[0].x0': t,
      'shapes[0].x1': t
    });
  }

  // update time display
  function updateTimeDisplay(){
    const cur = audioEl.currentTime || 0;
    timeDisplay.textContent = formatTime(cur) + ' / ' + formatTime(audioEl.duration || duration || 0);
  }

  function formatTime(s){
    if(!isFinite(s)) s = 0;
    const mm = Math.floor(s/60);
    const ss = Math.floor(s%60);
    return String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
  }

  // play/pause button
  playPauseBtn.addEventListener('click', async () => {
    if(!audioEl.src) return;
    if(audioEl.paused){
      try{
        await audioEl.play();
      }catch(e){
        console.error('play failed', e);
      }
    }else{
      audioEl.pause();
    }
  });

  // when audio plays/pauses update UI and RAF
  audioEl.addEventListener('play', () => {
    isPlaying = true;
    playPauseBtn.textContent = 'Pause';
    startPlayheadLoop();
  });
  audioEl.addEventListener('pause', () => {
    isPlaying = false;
    playPauseBtn.textContent = 'Play';
    stopPlayheadLoop();
    updateTimeDisplay();
  });
  audioEl.addEventListener('timeupdate', () => {
    // update time display (also updated in RAF)
    updateTimeDisplay();
  });
  audioEl.addEventListener('loadedmetadata', () => {
    updateTimeDisplay();
  });

  function startPlayheadLoop(){
    if(rafId) cancelAnimationFrame(rafId);
    const step = () => {
      const t = audioEl.currentTime || 0;
      setPlayhead(t);
      updateTimeDisplay();
      rafId = requestAnimationFrame(step);
    };
    rafId = requestAnimationFrame(step);
  }
  function stopPlayheadLoop(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  // ------------ Scrubbing / click handling ------------
  // We'll use pointer events on the plot div to compute relative X and map to time.
  function pageToTime(clientX){
    // bounding rect of the plotting area - use plotDiv's inner graph bounding
    const bbox = plotDiv.getBoundingClientRect();
    // We need to find the left/right padding where the axes actually are.
    // Simpler approach: compute percent across full width and map to duration.
    // This is good enough because xaxis spans the entire plot area horizontally.
    const px = Math.max(0, Math.min(bbox.width, clientX - bbox.left));
    const pct = px / bbox.width;
    return pct * (duration || 0);
  }

  plotDiv.addEventListener('pointerdown', (ev) => {
    if(!audioEl.src) return;
    scrubbing = true;
    wasPlayingBeforeScrub = !audioEl.paused;
    lastPlayedTime = audioEl.currentTime || 0;
    // if playing, pause for smoother scrubbing
    if(wasPlayingBeforeScrub){
      audioEl.pause();
    }
    // set immediate playhead and currentTime to preview
    const t = pageToTime(ev.clientX);
    audioEl.currentTime = t;
    setPlayhead(t);
    updateTimeDisplay();
    // capture pointer for move/up
    plotDiv.setPointerCapture(ev.pointerId);
  });

  plotDiv.addEventListener('pointermove', (ev) => {
    if(!scrubbing) return;
    const t = pageToTime(ev.clientX);
    // update preview position (do not start playing if originally paused)
    audioEl.currentTime = t;
    setPlayhead(t);
    updateTimeDisplay();
  });

  plotDiv.addEventListener('pointerup', async (ev) => {
    if(!scrubbing) return;
    scrubbing = false;
    plotDiv.releasePointerCapture(ev.pointerId);
    const releasedTime = pageToTime(ev.clientX);

    if(wasPlayingBeforeScrub){
      // user was playing: resume playback at releasedTime
      audioEl.currentTime = releasedTime;
      try { await audioEl.play(); } catch(e){ console.warn(e); }
    } else {
      // user was paused before scrubbing: revert playhead to lastPlayedTime (preview behavior)
      audioEl.currentTime = lastPlayedTime;
      await setPlayhead(lastPlayedTime);
      updateTimeDisplay();
    }
  });

  // also support clicking (no drag)
  plotDiv.addEventListener('click', async (ev) => {
    // If scrubbing is active, pointerup handled it. For simple clicks when not scrubbing:
    if(scrubbing) return;
    if(!audioEl.src) return;
    // If audio is playing, seek and continue
    const t = pageToTime(ev.clientX);
    if(!audioEl.paused){
      audioEl.currentTime = t;
    } else {
      // paused -> treat as preview click (jump temporarily and then return)
      const prev = audioEl.currentTime || 0;
      audioEl.currentTime = t;
      setPlayhead(t);
      // short preview: play for 800ms then return
      try {
        await audioEl.play();
        setTimeout(()=> {
          audioEl.pause();
          audioEl.currentTime = prev;
          setPlayhead(prev);
        }, 800);
      } catch(e){
        // if autoplay blocked, just revert immediately
        audioEl.currentTime = prev;
        setPlayhead(prev);
      }
    }
  });

  // utility: keep playhead when seeking by other controls
  audioEl.addEventListener('seeked', () => {
    setPlayhead(audioEl.currentTime || 0);
    updateTimeDisplay();
  });

})();
</script>
</body>
</html>
